---
title: Настройка всего на одном порту
---

# Один порт для всех

С помощью этого руководства вы сможете осуществлять все подключения к вашему серверу (панель управления, TLS-конфигурации и REALITY-конфигурации) через один (или два) порта. Цель данного подхода — сделать соединения с сервером более естественными, обойти ограничения на один порт и решить подобные задачи.

::: tip Примечание
Если вы меняли порт для панели управления и хотите, чтобы старые ссылки подписки продолжали работать, вы также можете, следуя этому руководству, настроить HAProxy на прослушивание старого порта и перенаправление входящего трафика на новый локальный порт, чтобы обе ссылки подписки функционировали. Для этого достаточно добавить старый порт аналогично порту 443.
:::

В этом руководстве мы используем HAProxy для достижения нашей цели. В дальнейшем предполагается, что поддомен панели — **panel.example.com**, поддомен для TLS-конфигураций — **sub.example.com**, а адрес SNI, используемый в REALITY-конфигурации — **reality.com**.

Таким образом, в этом руководстве мы сначала установим и настроим HAProxy, а затем внесем необходимые изменения в конфигурации и панель, чтобы весь трафик принимался через один порт. В конце приведены некоторые дополнительные замечания.

::: warning Внимание
Если ранее вы использовали HAProxy для получения SSL-сертификата для панели управления, то для панели SSL рекомендуем использовать другой метод (наш совет — UNIVCORN), чтобы избежать конфликтов с данными настройками.
:::

## Установка и настройка HAProxy

::: tip Примечание
В этом руководстве мы устанавливаем HAProxy непосредственно на сервер; если хотите, вы можете установить его в Docker.  
Также, если в будущем планируете использовать более сложные правила, не забудьте установить HAProxy из его официального репозитория, а не из стандартных репозиториев Linux.
:::

Сначала выполните следующие команды для установки:

```bash
apt update
apt install -y haproxy
```

После установки файл конфигурации HAProxy находится по адресу `/etc/haproxy/haproxy.cfg`. Откройте его для редактирования с помощью `nano`.

Затем добавьте в конец файла следующую конфигурацию (с учетом необходимых изменений согласно инструкциям) и сохраните файл.

::: code-group
```[haproxy.cfg]
listen front
 mode tcp
 bind *:443

 tcp-request inspect-delay 5s
 tcp-request content accept if { req_ssl_hello_type 1 }

 use_backend panel if { req.ssl_sni -m end panel.example.com }
 use_backend reality if { req.ssl_sni -m end reality.com }
 default_backend fallback

backend panel
 mode tcp
 server srv1 127.0.0.1:10000

backend fallback
 mode tcp
 server srv1 127.0.0.1:11000

backend reality
 mode tcp
 server srv1 127.0.0.1:12000 send-proxy
```
:::

Конфигурация HAProxy состоит из одного или нескольких **frontend** и **backend**. Каждый frontend направляет трафик к одному из backend'ов в соответствии с заданными правилами. Понимание этих двух компонентов поможет лучше настроить HAProxy.

Из приведенной конфигурации видно, что HAProxy прослушивает порт 443 на сервере и принимает весь трафик. Затем, исходя из SNI входящего запроса, трафик перенаправляется на соответствующий локальный порт сервера, что позволяет разделять различные типы трафика.

::: tip Примечание
В данной конфигурации определен backend по умолчанию с помощью `default_backend`. Если входящий трафик не соответствует ни одному из указанных SNI, он перенаправляется к этому backend. Вы можете удалить этот фрагмент, чтобы блокировать трафик, не соответствующий указанным SNI.
:::

После того как вы замените домены на свои и добавите эту конфигурацию в конец файла, перезапустите HAProxy командой:

```bash
systemctl restart haproxy
```

## Подготовка конфигураций

### Подготовка конфигурации REALITY

Предположим, что вы хотите иметь несколько inbound-конфигураций для каждого нода или несколько inbound-конфигураций с различными SNI. Если просто разместить эти inbound'ы подряд и назначить им одинаковый порт, соединение будет нестабильным, и установить связь практически невозможно.

Использование одного порта для всех конфигураций решает эту проблему. Для этого измените настройки ваших конфигураций следующим образом (обратите внимание на строки 3, 4 и 13):

::: code-group
```json{3-4,13} [xray_config.json]
{
  "tag": "VLESS_TCP_REALITY",
  "listen": "127.0.0.1",
  "port": 12000,
  "protocol": "vless",
  "settings": {
    "clients": [],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "tcp",
    "tcpSettings": {
      "acceptProxyProtocol": true
    },
    "security": "reality",
    "realitySettings": {
      "show": false,
      "dest": "x",
      "xver": 0,
      "serverNames": [
        "reality.com"
      ],
      "privateKey": "x",
      "shortIds": [
        ""
      ]
    }
  },
  "sniffing": {
    "enabled": true,
    "destOverride": [
      "http",
      "tls"
    ]
  }
}
```
:::

### Подготовка TLS-конфигураций

Чтобы запустить все виды TLS-конфигураций на одном порту, мы используем fallback (если вы уже использовали fallback для работы на одном порту, можете пропустить этот шаг и просто привести порт вашей fallback-конфигурации в соответствие с HAProxy).

Сначала нам нужен inbound fallback. Для этого можно использовать следующий пример inbound:

::: code-group
```json{3-4,13} [xray_config.json]
{
    "tag": "TROJAN_FALLBACK_INBOUND",
    "port": 11000,
    "protocol": "trojan",
    "settings": {
        "clients": [],
        "decryption": "none",
        "fallbacks": [
            {
                "path": "/lw",
                "dest": "@vless-ws",
                "xver": 2
            },
            {
                "path": "/mw",
                "dest": "@vmess-ws",
                "xver": 2
            },
            {
                "path": "/tw",
                "dest": "@trojan-ws",
                "xver": 2
            }
        ]
    },
    "streamSettings": {
        "network": "tcp",
        "security": "tls",
        "tlsSettings": {
            "serverName": "SERVER_NAME",
            "certificates": [
                {
                    "ocspStapling": 3600,
                    "certificateFile": "/var/lib/marzban/certs/fullchain.pem",
                    "keyFile": "/var/lib/marzban/certs/key.pem"
                }
            ],
            "minVersion": "1.2",
            "cipherSuites": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "alpn": [
                "http/1.1"
            ]
        }
    },
    "sniffing": {
        "enabled": true,
        "destOverride": [
            "http",
            "tls"
        ]
    }
},
```
:::

Чтобы лучше использовать данную возможность, полезно понять её концепцию и принцип работы. Fallback действует следующим образом: если входящий трафик соответствует данному inbound, он принимается; если нет — перенаправляется к другим inbound'ам в зависимости от пути (path). Таким образом, после настройки fallback, создайте несколько других inbound-конфигураций, каждая из которых соответствует одному из путей, указанных в fallback. (Если такие inbound'ы уже существуют, достаточно изменить значение их параметра `listen` на заданное (например, `@vless-ws`, `@vmess-ws` или `@trojan-ws`), а также установить их путь (path) в fallback.)

То есть, fallback перенаправляет входящий трафик по следующим правилам:

```
path = /lw     ->    listen: "@vless-ws"
path = /mw     ->    listen: "@vmess-ws"
path = /tw     ->    listen: "@trojan-ws"
```

Таким образом, согласно приведенному примеру, достаточно привести в соответствие значения `listen` и `path` ваших inbound-конфигураций с fallback, чтобы все они работали на одном порту.

::: tip Примечание
Использование fallback увеличивает нагрузку на сервер. Вы можете для каждой конфигурации назначить отдельный поддомен и, используя HAProxy, настроить TLS-конфигурации на одном порту без fallback.
:::

::: warning Внимание
Обратите внимание, что для тех inbound-конфигураций, у которых значение `listen` имеет вид `@xxx` и которые используются во fallback, строку, относящуюся к порту, следует удалить.
:::

Если вы настроили inbound-конфигурации на одном порту с помощью fallback, откройте файл `.env` и установите следующую переменную равной тегу вашего inbound fallback:

```
XRAY_FALLBACKS_INBOUND_TAG = "TROJAN_FALLBACK_INBOUND"
```

## Настройка панели

Как уже было сказано, наша цель — использование одного порта для всех подключений, включая панель (ссылки подписки). Ранее настройки панели были внесены в конфигурацию HAProxy, и теперь достаточно привести порт, на котором панель слушает, в соответствие с HAProxy. Для этого отредактируйте файл `.env` и установите следующие переменные равными значениям, указанным в HAProxy (или любым другим, которые вы выбрали):

```
UVICORN_HOST = "127.0.0.1"
UVICORN_PORT = 10000
```

После этого перезапустите Marzban:

```bash
marzban restart
```

## Настройка host settings

Поскольку порт, указанный в inbound-конфигурации, является локальным, а фактически весь трафик поступает на ваш сервер через порт 443, необходимо в разделе host settings ваших конфигураций изменить порт на 443. Иначе по умолчанию для конфигураций будут использоваться локальные порты.

## Дополнительные замечания

::: warning Внимание
Настройки HAProxy должны быть выполнены на всех нод-серверах. Либо вы можете определить отдельный inbound для некоторых нод и настроить прослушивание напрямую на `0.0.0.0`.
:::

::: tip Примечание
В предложенной конфигурации HAProxy весь трафик, не совпадающий с SNI **panel.example.com** или **reality.com**, перенаправляется к inbound fallback, что предотвращает злоупотребление вашим IP в качестве «чистого» IP от Cloudflare.
:::

::: warning Предупреждение
Если вы используете IP-лимитер, необходимо добавить параметр `send-proxy` в конце каждой строки с сервером в backend-конфигурации HAProxy, а также установить значение `"acceptProxyProtocol": true` в вашей inbound-конфигурации, как показано в примере REALITY выше. Если конфигурация содержит `send-proxy`, но отсутствует `"acceptProxyProtocol": true`, соединение не установится.
:::
