---
title: Настройка всего на одном порту
---

# Один порт для всего
С помощью этой инструкции вы сможете осуществлять все соединения с вашим сервером (панель, конфигурации с TLS и конфигурации REALITY) через один (или два) порта.
Цель этого - сделать соединения с сервером более естественными, обойти ограничения на один порт или решить подобные задачи.


::: tip Примечание
Если вы меняли порт своей панели со временем и хотите, чтобы старые ссылки на подписки продолжали работать, вы также можете с помощью этой инструкции настроить HAProxy для прослушивания на старом порту и перенаправления входящего трафика на новый локальный порт, чтобы обе ссылки на подписки работали. Для этого достаточно добавить свой предыдущий порт так же, как порт 443.
:::


В этой инструкции мы используем инструмент HAProxy для достижения нашей цели. Далее в инструкции предполагается, что поддомен панели - panel.example.com,
поддомен для конфигураций с TLS - sub.example.com, а адрес SNI, используемый в конфигурации reality - reality.com.

Итак, в этой инструкции мы сначала установим и настроим HAProxy, а затем внесем необходимые изменения в конфигурации и панель, чтобы они принимали весь трафик на одном порту. В конце приведены некоторые дополнительные примечания.


::: warning Внимание
Если вы ранее использовали HAProxy для получения SSL для своей панели, вам следует использовать другой метод (мы рекомендуем UNIVCORN) для получения SSL для панели, чтобы избежать конфликта с этими настройками
:::


## Установка и настройка HAProxy

::: tip Примечание
В этой инструкции мы устанавливаем HAProxy напрямую на сервер; при желании вы можете установить его в Docker самостоятельно.

Также, если в будущем вы планируете применять более сложные правила, не забудьте установить HAProxy из его основного репозитория, а не из репозиториев Linux.
:::


Сначала для установки выполните следующие команды:

```bash
apt update
apt install -y haproxy
```

После установки файл конфигурации HAProxy находится по адресу `/etc/haproxy/haproxy.cfg`. Откройте этот файл для редактирования с помощью `nano`.

Теперь добавьте следующую конфигурацию в конец файла конфигурации после внесения изменений согласно инструкциям и сохраните его.


::: code-group
```[haproxy.cfg]
listen front
 mode tcp
 bind *:443

 tcp-request inspect-delay 5s
 tcp-request content accept if { req_ssl_hello_type 1 }

 use_backend panel if { req.ssl_sni -m end panel.example.com }
 use_backend reality if { req.ssl_sni -m end reality.com }
 default_backend fallback

backend panel
 mode tcp
 server srv1 127.0.0.1:10000

backend fallback
 mode tcp
 server srv1 127.0.0.1:11000

backend reality
 mode tcp
 server srv1 127.0.0.1:12000 send-proxy

```
:::


Конфигурации HAProxy включают один или несколько frontend и один или несколько backend. Каждый frontend направляет трафик к одному из backend на основе правил, определенных в нем. Понимание этих двух разделов помогает нам лучше настроить HAProxy.

Внимательно изучив эту конфигурацию, вы можете понять, что с ее помощью HAProxy прослушивает порт 443 сервера и принимает весь трафик. Затем, на основе sni входящего трафика, он перенаправляет его на "локальный" порт сервера, и таким образом мы можем различать разные типы трафика.


::: tip Примечание
В этой конфигурации определен backend по умолчанию с использованием default_backend, который принимает трафик, если входящий трафик не соответствует двум определенным sni. Вы можете удалить эту часть кода, чтобы блокировать трафик, не соответствующий указанным sni.
:::

После замены ваших доменов и размещения этой конфигурации в конце указанного файла, перезапустите HAProxy следующей командой, чтобы завершить этот этап.

```bash
systemctl restart haproxy
```

## Подготовка конфигураций
### Подготовка конфигурации REALITY
 Предположим, вы хотите иметь несколько различных входящих соединений для каждого узла или несколько различных входящих соединений с разными sni. Если вы просто разместите эти входящие соединения одно за другим и установите для них одинаковый порт, соединение будет нарушено, и фактически установить соединение будет невозможно.

 Настройка одного порта для конфигураций решает эту проблему. Для этого вам нужно изменить настройки ваших конфигураций следующим образом (обратите внимание на строки 3, 4 и 13):

::: code-group
```json{3-4,13} [xray_config.json]
{
  "tag": "VLESS_TCP_REALITY",
  "listen": "127.0.0.1",
  "port": 12000,
  "protocol": "vless",
  "settings": {
    "clients": [],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "tcp",
    "tcpSettings": {
      "acceptProxyProtocol": true
    },
    "security": "reality",
    "realitySettings": {
      "show": false,
      "dest": "x",
      "xver": 0,
      "serverNames": [
        "reality.com"
      ],
      "privateKey": "x",
      "shortIds": [
        ""
      ]
    }
  },
  "sniffing": {
    "enabled": true,
    "destOverride": [
      "http",
      "tls"
    ]
  }
}
```
:::


С этими изменениями ваше входящее соединение будет прослушивать 127.0.0.1 или локальный хост вместо 0.0.0.0, и вы можете создать любое количество входящих соединений таким образом (с разными локальными портами) и различать их в HAProxy на основе sni.

### Подготовка конфигураций с TLS
Чтобы иметь все типы конфигураций с TLS на одном порту, мы используем fallback (если вы уже использовали fallback для настройки одного порта, пропустите этот шаг и просто согласуйте порт вашей конфигурации fallback с HAProxy)

Сначала нам нужно входящее соединение fallback. Для этого вы можете использовать следующее входящее соединение в качестве примера:

::: code-group
```json{3-4,13} [xray_config.json]
{
    "tag": "TROJAN_FALLBACK_INBOUND",
    "port": 11000,
    "protocol": "trojan",
    "settings": {
        "clients": [],
        "decryption": "none",
        "fallbacks": [
            {
                "path": "/lw",
                "dest": "@vless-ws",
                "xver": 2
            },
            {
                "path": "/mw",
                "dest": "@vmess-ws",
                "xver": 2
            },
            {
                "path": "/tw",
                "dest": "@trojan-ws",
                "xver": 2
            }
        ]
    },
    "streamSettings": {
        "network": "tcp",
        "security": "tls",
        "tlsSettings": {
            "serverName": "SERVER_NAME",
            "certificates": [
                {
                    "ocspStapling": 3600,
                    "certificateFile": "/var/lib/marzban/certs/fullchain.pem",
                    "keyFile": "/var/lib/marzban/certs/key.pem"
                }
            ],
            "minVersion": "1.2",
            "cipherSuites": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "alpn": [
                "http/1.1"
            ]
        }
    },
    "sniffing": {
        "enabled": true,
        "destOverride": [
            "http",
            "tls"
        ]
    }
},
```
:::


Для лучшего использования этой функции полезно понять ее концепцию и работу. Fallback в целом работает так: если входящий трафик соответствует этому входящему соединению, он принимает его, а если нет, то направляет его к другим входящим соединениям в зависимости от path. Итак, после размещения входящего соединения с fallback, мы определяем несколько других входящих соединений, каждое с path, указанным во входящем соединении fallback (если у вас уже есть такие входящие соединения, достаточно изменить значение listen на определенные значения (@vless-ws, @vmess-ws и @trojan-ws) и включить их path во входящее соединение fallback.

Таким образом, входящее соединение fallback направляет каждый входящий трафик к другим входящим соединениям на основе path:

```
path = /lw     ->    listen: "@vless-ws"
path = /mw     ->    listen: "@vmess-ws"
path = /tw     ->    listen: "@trojan-ws"
```

Итак, согласно приведенному выше примеру, достаточно согласовать разделы listen и path ваших входящих соединений с fallback, чтобы все конфигурации работали на одном порту.


::: tip Примечание
Использование fallback увеличивает нагрузку на обработку сервера. Вы можете назначить разный поддомен для каждой конфигурации и использовать тот же HAProxy без необходимости в fallback для настройки конфигураций с TLS на одном порту.
:::


::: warning Внимание
Обратите внимание, что во входящих соединениях, где значение listen имеет формат @xxx и используется в fallback, удалите строку, относящуюся к port
:::


Теперь, если вы настроили входящие соединения на один порт с помощью этого метода fallback, откройте файл `.env` и установите следующую переменную равной тегу вашего входящего соединения fallback:

```
XRAY_FALLBACKS_INBOUND_TAG = "TROJAN_FALLBACK_INBOUND"
```

## Подготовка панели
Как было сказано, наша цель - иметь все соединения, включая панель (ссылку на подписку), на одном порту. Ранее мы ввели настройки для панели в конфигурации HAProxy, и на этом этапе достаточно согласовать порт, на котором прослушивает панель, с HAProxy. Итак, для этого достаточно отредактировать файл `.env` и установить следующие переменные равными определенному значению (или любому значению, которое вы ввели в HAProxy):


```
UVICORN_HOST = "127.0.0.1"
UVICORN_PORT = 10000
```


Теперь перезапустите Marzban:

```bash
marzban restart
```

## Подготовка настроек хоста
Поскольку порт, который вы указали во входящем соединении, является локальным портом, и фактически весь трафик поступает на ваш сервер через порт 443, необходимо в разделе настроек хоста для созданных конфигураций самостоятельно изменить порт на 443, иначе по умолчанию для конфигураций будут установлены локальные порты.

## Дополнительные примечания:
::: warning Внимание
Требования к настройкам HAProxy должны быть выполнены на всех серверах нодах, или вы можете определить отдельные входящие соединения для некоторых нодов и просто подключить их напрямую к `0.0.0.0`.
:::


::: tip Внимание
В конфигурации, которую мы добавили для HAProxy, все трафик, который не соответствует ни одному из sni panel.example.com и reality.com, передается на входящее соединение fallback, и в результате этого ваш IP, используемый как IP чистого клиента, забирается для использования чистым клиентом.
:::


::: warning Предупреждение
Если вы используете ограничитель IP, вы должны добавить выражение `send-proxy` в конец каждого серверного backend в HAProxy и также установить `"acceptProxyProtocol": true` в конфигурации вашего входящего соединения, как показано в примере для REALITY выше. Если у вас есть входящее соединение `send-proxy`, но нет `"acceptProxyProtocol": true`, соединение не будет установлено.
:::

